"""Endpoints: Enumerations"""
from typing import Dict, List

import yaml

from fastapi import APIRouter, HTTPException
from linkml_runtime.linkml_model import EnumDefinition, PermissibleValue
from linkml_runtime.dumpers.yaml_dumper import YAMLDumper
from starlette.responses import Response

from ccdh.api.utils import uri_to_curie
from ccdh.config import neo4j_graph
from ccdh.db.mdr_graph import MdrGraph

mdr_graph = MdrGraph(neo4j_graph())

router = APIRouter(
    prefix='/enumerations',
    tags=['Enumerations'],
    dependencies=[],
    responses={404: {"description": "Not found"}},
)


# Support functions ------------------------------------------------------------
# TODO: put in utils; later to be put in linkml-runtime utils
def is_nonequivalent_subset(subset, superset):
    """Is subset actually a subset of superset, and not wholly equivalent?"""
    return is_subset(subset, superset) and subset != superset


# TODO: put in utils; later to be put in linkml-runtime utils
def is_subset(subset, superset):
    """Is subset actually a subset of superset."""
    if isinstance(subset, dict):
        return all(key in superset and is_subset(val, superset[key]) for key, val in subset.items())

    if isinstance(subset, list) or isinstance(subset, set):
        return all(any(is_subset(subitem, superitem) for superitem in superset) for subitem in subset)

    # assume that subset is a plain value if none of the above match
    return subset == superset


# Work functions ---------------------------------------------------------------
def enum_from_sys_ent_attr(system, entity, attribute, value_only: bool = False) -> Dict:
    """Get enumeration from system, entity, attribute"""
    name: str = f'{system}.{entity}.{attribute}'
    enum = EnumDefinition(name=name, description=f'Autogenerated Enumeration for {system} {entity} {attribute}')
    enum.permissible_values = []
    if value_only:
        values = mdr_graph.find_permissible_values_of(system, entity, attribute)
        for v in values:
            enum.permissible_values.append(PermissibleValue(text=v['pref_label'], description=v['description']))
    else:
        concepts, values = mdr_graph.find_concept_references_and_permissible_values_of(system, entity, attribute)
        for v in values:
            node_attributes = v['node_attributes']
            contexts = []
            for attr in node_attributes:
                contexts.append(f'{attr["system"]}.{attr["entity"]}.{attr["attribute"]}')
            # extensions = {'CCDH:context': '; '.join(contexts)}
            pv = PermissibleValue(text=v['pref_label'], description=v['description'])
            enum.permissible_values.append(pv)
        for concept in concepts:
            concept = dict(concept['cr'])
            pv = PermissibleValue(
                meaning=uri_to_curie(concept['uri']),
                description=concept['designation'],
                text=concept['code'])
            enum.permissible_values.append(pv)

    enum_dump: str = YAMLDumper().dumps(enum)
    enum_dict: Dict = yaml.safe_load(enum_dump)

    if 'permissible_values' in enum_dict:
        val_objs: Dict[str, str] = enum_dict['permissible_values']
        for val_obj in val_objs:
            for i in range(len(enum_dict['permissible_values'])):
                original_val_obj = enum_dict['permissible_values'][i]
                subset_found = is_nonequivalent_subset(original_val_obj, val_obj)
                if subset_found:
                    enum_dict['permissible_values'][i] = 'dupe'
        enum_dict['permissible_values'] = [
            x for x in enum_dict['permissible_values'] if x != 'dupe']
    else:
        # enum_dict['permissible_values'] = []
        pass

    return enum_dict


def enums_all(value_only: bool = False) -> Dict:
    """Get all enumerations DB"""
    model_names: List[str] = mdr_graph.list_models()
    res = {
        k: {}
        for k in model_names
    }
    for mdl in model_names:
        entity_names: List[str] = mdr_graph.list_entities(mdl)
        res[mdl] = {
            k: {}
            for k in entity_names
        }
        for ent in entity_names:
            attr_names: List[str] = mdr_graph.list_attributes(mdl, ent)
            res[mdl][ent] = {
                k: {}
                for k in attr_names
            }
            for attr in attr_names:
                enum: Dict = enum_from_sys_ent_attr(mdl, ent, attr, value_only)
                res[mdl][ent][attr] = enum
                # TODO: Temp
                if 'permissible_values' in enum:
                    print()
    return res


# Endpoint functions -----------------------------------------------------------
@router.get('/all',
            response_model_exclude_none=True,
            response_model_exclude_unset=True,
            response_class=Response,
            responses={
                200: {
                    "content": {
                        'application/x-yaml': {}
                    },
                    "description": 'Return all enumerations for all models.',
                }
            })
async def get_enumerations_all(value_only: bool = False) -> Response:
    """Get all enumerations for all models"""
    response_dict = enums_all(value_only)
    res: str = yaml.dump(response_dict)
    return Response(content=res, media_type="application/x-yaml")


path_desc = ''


@router.get('/from_path/{path}',
            response_model_exclude_none=True,
            response_model_exclude_unset=True,
            response_class=Response,
            responses={
                200: {
                    "content": {
                        'application/x-yaml': {}
                    },
                    "description": 'Return enumerations from a given node path, '
                    'as "model.entity.attribute".',
                }
            })
async def get_enumeration_from_path(name: str, value_only: bool = False) -> Response:
    """Endpoint: get enumeration from path"""
    if len(name.split('.')) != 3:
        raise HTTPException(
            status_code=422,
            detail='Incorrect path syntax. Must return in form of "model.entity.attribute".')
    system, entity, attribute = name.split('.')
    enum_dict: Dict = enum_from_sys_ent_attr(system, entity, attribute, value_only)
    enum_yml_str: str = yaml.dump(enum_dict)
    return Response(content=enum_yml_str, media_type="application/x-yaml")


if __name__ == '__main__':
    enums_all()  # temp debugging
